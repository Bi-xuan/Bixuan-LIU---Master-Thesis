# Library

```{r}
library('fBasics')
library('Matrix')
library("matrixcalc")

library("ggplot2")
theme_set(theme_bw())

library("scatterplot3d") # load

library(dplyr)
library(tidyr)

library(reshape2)
```

# Algorithm: Splitting

## Algo1

```{r}
n <- 3
Lambda <- rbind(c(0.5,0,0.9),c(0,0.6,0.7),c(0,0,0.5))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_1 <- matrix(runif(n**2,-1,1),ncol=n)
# Lambda_2 <- matrix(runif(n**2,-1,1),ncol=n)
cond <- FALSE
dis <- c()

while(1) {
  Lambda_2 <- t(solve(Sigma %*% Lambda_1)) %*% (Sigma - omega * diag(n))
  dis <- c(dis,norm(Lambda_2 - Lambda_1, type="2"))
  if(norm(Lambda_2 - Lambda_1, type="2") <1e-6) {
    break
  }else {
    Lambda_1 <- Lambda_2
  }
}

```

# ISTA / FISTA

n=3

```{r}
n <- 3
Lambda_0 <- Lambda_star[[1]]
# Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-t(Lambda_0) %x% t(Lambda_0)) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

frobenius.norm(Sigma)
```

```{r}
# Initialization
eta <- 0.001 # Stepsize
gma <- 2.3 # l1 penalty
obj <- list(1)
obj_gap <- list(1)

# Lambda <-list(matrix(runif(n**2,-1,1),ncol=n))
# Lambda <-list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)
# Lambda <-list(matrix(0,n,n))

# grad <- -4 * (Sigma %*% Lambda[[i]]) %*% (2*(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) -  diag(diag(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega*diag(n))))

for (i in 1:1000) {
  grad <- -2 * ((Sigma %*% Lambda[[i]]) %*% (Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n))
  Lambda[[i+1]] <- matrix(0,n,n)
  for (j in 1:n) {
    for(k in 1:n) {
      grad_step <- Lambda[[i]][j,k] - eta * grad[j,k]
     if (j == k) {
       Lambda[[i+1]][j,k] <- grad_step
     }else if(grad_step < -eta * gma) {
        Lambda[[i+1]][j,k] <- grad_step + eta*gma
      }else if (grad_step > eta * gma) {
        Lambda[[i+1]][j,k] <- grad_step - eta*gma
      }else {
        Lambda[[i+1]][j,k] <- 0
      }
    }
  }
  obj[[i+1]] <- frobenius.norm(Sigma - Lambda[[i]]%*%Sigma%*%t(Lambda[[i]]) - omega * diag(n)) + gma * sum(abs(c(Lambda[[i]]) - c(diag(diag(Lambda[[i]])))))
  obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
  if(obj_gap[[i+1]] < 1e-6) {
    print("Converged.")
    break
  }
}

Lambda[[i]]
```

ISTA with backtracking

```{r}
# ISTA update with stepsize eta
ft_ISTA_update <- function(Lambda_0,Sigma,gma,eta) {
     grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_0[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
        }else if(grad_step < -eta * gma) {
          Lambda_updt[j,k] <- grad_step + eta*gma
        }else if (grad_step > eta * gma) {
          Lambda_updt[j,k] <- grad_step - eta*gma
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}
```

```{r}
# Initialization
eta <- list(10) # Stepsize
eta_inc <- 1.5 # The increment of stepsize, a constant > 1
gma <- 3.5 # l1 penalty
obj <- list(1)
obj_gap <- list(1)

# Lambda <- list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)
obj[[1]] <- frobenius.norm(Sigma - t(Lambda[[1]])%*%Sigma%*%Lambda[[1]] - omega * diag(n)) + gma * sum(abs(c(Lambda[[1]]) - c(diag(diag(Lambda[[1]])))))

for (i in 1:10000) {
  for (l in 0:1000) {
    eta_t <- eta[[i]] / (eta_inc ** l)
    ISTA_updt <- ft_ISTA_update(Lambda[[i]],Sigma,gma,eta_t)
    Lambda_updt <- ISTA_updt[[1]]
    grad_updt <- ISTA_updt[[2]]
    if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
      eta[[i+1]] <- eta_t
      break
    }
  }
  ISTA_updt <- ft_ISTA_update(Lambda[[i]],Sigma,gma,eta[[i+1]])
  Lambda[[i+1]] <- ISTA_updt[[1]]
  obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * sum(abs(c(Lambda[[i+1]]) - c(diag(diag(Lambda[[i+1]])))))
  obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
  if(obj_gap[[i+1]] < 1e-6) {
    print("Converged.")
    break
  }
}

Lambda[[i+1]]
```

## Test: gradient descent

```{r}
eta <- 0.001 # Stepsize
fnorm <- list(1)
obj <- list(1)

Lambda <-list(matrix(runif(n**2,-1,1),ncol=n))

for (i in 1:1000) {
  grad <- -2 * ((Sigma %*% Lambda[[i]]) %*% (Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n))
  Lambda [[i+1]] <- Lambda[[i]] - eta * grad
  
  fnorm[[i+1]] <- frobenius.norm(Lambda[[i+1]] - Lambda[[i]])
  obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n))
  
  if(fnorm[[i+1]] < 1e-6) {
    print("Succeed!")
    break
  }
}
```

## Witness approach

Verify if the lasso solution is the optim.

n=3

```{r}
n <- 3
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)))
Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)
```

ISTA with backtracking and constraints on the support

```{r}
# ISTA update with stepsize eta
ft_ISTA_update <- function(Lambda_0,Lambda_k,Sigma,gma,eta) {
     grad <- -4 * ((Sigma %*% Lambda_k) %*% (Sigma - t(Lambda_k)%*%Sigma%*%Lambda_k - omega * diag(n)))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_k[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
      }else if(Lambda_0[j,k] == 0){
          Lambda_updt[j,k] <- 0
        }else if(grad_step < -eta * gma) {
          Lambda_updt[j,k] <- grad_step + eta*gma
        }else if (grad_step > eta * gma) {
          Lambda_updt[j,k] <- grad_step - eta*gma
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}
```

```{r}
# Initialization
eta <- list(10) # Stepsize
eta_inc <- 1.1 # The increment of stepsize, a constant > 1
gma <- 0.1 # l1 penalty
obj <- list(1)
obj_gap <- list(1)

# Lambda <- list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)
obj[[1]] <- frobenius.norm(Sigma - t(Lambda[[1]])%*%Sigma%*%Lambda[[1]] - omega * diag(n)) ** 2 + gma * sum(abs(c(Lambda[[1]]) - c(diag(diag(Lambda[[1]])))))

for (i in 1:10000) {
  for (l in 0:1000) {
    eta_t <- eta[[i]] / (eta_inc ** l)
    ISTA_updt <- ft_ISTA_update(Lambda_0,Lambda[[i]],Sigma,gma,eta_t)
    Lambda_updt <- ISTA_updt[[1]]
    grad_updt <- ISTA_updt[[2]]
    if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) ** 2 > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) ** 2 + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
      eta[[i+1]] <- eta_t
      break
    }
  }
  ISTA_updt <- ft_ISTA_update(Lambda_0,Lambda[[i]],Sigma,gma,eta[[i+1]])
  Lambda[[i+1]] <- ISTA_updt[[1]]
  obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) ** 2 + gma * sum(abs(c(Lambda[[i+1]]) - c(diag(diag(Lambda[[i+1]])))))
  obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
  if(obj_gap[[i+1]] < 1e-6) {
    print("Converged.")
    break
  }
}

Lambda[[i+1]]
```



## Algo: to construct a chain of \gamma

ADMM

```{r}
ft_ADMM <- function(Sigma,omega,beta=0.5) {
  # Initialization
  Lambda_1 <- list(matrix(runif(n**2,-1,1),ncol=n))
  Lambda_2 <- list(matrix(runif(n**2,-1,1),ncol=n))
  alpha <- list(matrix(0,n,n))
  dis_1_2 <- list(1)
  obj <- list(1)
  
  for (i in 1:1000) {
    Lambda_1[[i+1]] <- solve(2*(Sigma %*% Lambda_2[[i]] %*% t(Lambda_2[[i]]) %*% Sigma) + beta * diag(n)) %*% (2*(Sigma %*% Lambda_2[[i]] %*% (Sigma - omega * diag(n))) - alpha[[i]] + beta * Lambda_2[[i]])
    Lambda_2[[i+1]] <- solve(2*Sigma %*% Lambda_1[[i+1]] %*% t(Lambda_1[[i+1]]) %*% Sigma + beta * diag(n)) %*% (2 * Sigma %*% Lambda_1[[i+1]] %*% (Sigma - omega * diag(n)) + alpha[[i]] + beta * Lambda_1[[i+1]])
    alpha[[i+1]] <- alpha[[i]] + beta * (Lambda_1[[i+1]] - Lambda_2[[i+1]])
    dis_1_2[[i+1]] <- frobenius.norm(Lambda_1[[i+1]] - Lambda_2[[i+1]])
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)) ** 2
  
  
    if(dis_1_2[[i+1]] < 1e-6 & obj[[i+1]] < 1e-6) {
      # print("ADMM succeeds!")
      return(list(Lambda_1[[i+1]],obj[[i+1]])) # Return the converged \Lambda and the objective function value
    }
  }
  print("ADMM did not converge after 1000 iterations.")
  return(list(Lambda_1[[i+1]],obj[[i+1]]))
}
```

ISTA with backtracking

```{r}
# grad <- -4 * t((Sigma %*% Lambda_0) %*% (2*(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) -  diag(diag(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega*diag(n)))))

# ISTA update with stepsize eta
ft_ISTA_update <- function(Lambda_0,Sigma,omega,gma,eta) {
    grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_0[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
        }else if(grad_step < -eta * gma) {
          Lambda_updt[j,k] <- grad_step + eta*gma
        }else if (grad_step > eta * gma) {
          Lambda_updt[j,k] <- grad_step - eta*gma
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}

ft_ISTA_bktr <- function(Lambda_0,Sigma,omega,gma,eta_0, eta_inc) {
  # eta_0 is the initial stepsize (before backtracking)
  eta <- list(eta_0)
  
  Lambda <- list(Lambda_0)
  obj <- list(frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) + gma * sum(abs(c(Lambda_0) - c(diag(diag(Lambda_0))))))
  obj_gap <- list(obj[[1]])
  
  for (i in 1:10000) {
    for (l in 0:1000) {
      eta_t <- eta[[i]] / (eta_inc ** l)
      ISTA_updt <- ft_ISTA_update(Lambda[[i]],Sigma,omega,gma,eta_t)
      Lambda_updt <- ISTA_updt[[1]]
      grad_updt <- ISTA_updt[[2]]
      if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
        eta[[i+1]] <- eta_t
        break
      }
    }
    ISTA_updt <- ft_ISTA_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
    Lambda[[i+1]] <- ISTA_updt[[1]]
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * sum(abs(c(Lambda[[i+1]]) - c(diag(diag(Lambda[[i+1]])))))
    obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
    if(obj_gap[[i+1]] < 1e-6) {
      return(list(Lambda[[i+1]],obj[[i+1]]))
    }
  }
  print("ISTA did not converge within 10000 iterations. Objective gap:")
  print(obj_gap[[i+1]])
  return(list(Lambda[[i+1]],obj[[i+1]]))
}
```


n=3

```{r}
n <- 3
Lambda_0 <- Lambda_star[[3]]
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

frobenius.norm(Sigma)
```

```{r}
beta <- 0.5
res_ADMM <- ft_ADMM(Sigma,omega, beta)
```

```{r}

Lambda <- list(Lambda_init[[5]])

eta <- 1
eta_inc <- 1.05
# gma_cand <- log(seq(100,1,-0.1),2)
gma_cand <- log(seq(1,100,0.1),5)
gma <- c(gma_cand[1])
# gma_cand <- 10 ** (seq(-5,log10(2.5),0.003))
# gma_cand <- seq(0,2,0.001)
res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[1]],Sigma,omega,gma[1],eta,eta_inc)
Lambda[[1]] <- res_ISTA_bktr[[1]]
obj <- list(res_ISTA_bktr[[2]])

k <- 1

for (i in 1:100) {
  Lambda[[i+1]] <- Lambda[[i]]
  while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
    k <- k + 1
    t_gma <- gma_cand[k]
    res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
    Lambda[[i+1]] <- res_ISTA_bktr[[1]]
    
    if(k == length(gma_cand)) break
  }
  obj[[i+1]] <- res_ISTA_bktr[[2]]
  gma[i+1] <- t_gma
  if(nnzero(Lambda[[i+1]]) == n || k == length(gma_cand)) break
}

Lambda

gma
```

Proportion of the case where we find the true graph

```{r}
num_exp <- 10
res_pos <- 0
res_pos_t <- 0

eta <- 1
eta_inc <- 1.05

for (j in 1:num_exp) {
  Lambda <- list(matrix(runif(n**2,-1,1),n,n))
  gma <- list(0)
  obj <- list(frobenius.norm(Sigma - t(Lambda[[1]])%*%Sigma%*%Lambda[[1]] - omega * diag(n)))
  err_edges <- list(sum((Lambda_0 != 0) != (Lambda[[1]] != 0)))
  err_edges_t <- list(sum((Lambda_0 != 0) != (t(Lambda[[1]]) != 0)))

  for (i in 1:100) {
    Lambda[[i+1]] <- Lambda[[i]]
    t_gma <- gma[[i]]
    while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
      t_gma <- t_gma + 0.01
      res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
      Lambda[[i+1]] <- res_ISTA_bktr[[1]]
    }
    obj[[i+1]] <- res_ISTA_bktr[[2]]
    gma[[i+1]] <- t_gma
    err_edges[[i+1]] <- sum((Lambda_0 != 0) != (Lambda[[i+1]] != 0))
    err_edges_t[[i+1]] <- sum((Lambda_0 != 0) != (t(Lambda[[i+1]]) != 0))
    if(nnzero(Lambda[[i+1]]) == n) {
      break
    }
  }
  
  if (0 %in% err_edges) {
    res_pos <- res_pos+1
  }else if (0 %in% err_edges_t) {
    res_pos_t <- res_pos_t + 1
  }
}

print(res_pos / num_exp)
print(res_pos_t / num_exp)
```

## Algo to do a grid of \gamma
```{r}
source("functions.R")
load("result/Accuracy/res_3.RData")
n <- 3

# Lambda_supp <- rbind(c(1,0,1),
#                      c(0,1,1),
#                      c(1,1,1))
# Lambda_0 <- Lambda_supp
# Lambda_0[Lambda_supp == 1] <- runif(sum(Lambda_supp))

Lambda_0 <- Lambda_star[[9]]

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Lambda_init <- lapply(1:10, function(x) matrix(runif(n**2,-1,1), n,n))
```


```{r}
df <- data.frame(lmd = numeric(), gma = numeric(), obj = numeric(), init_id = character())

for (k in 1:length(Lambda_init)) {
  Lambda <- list(Lambda_init[[k]])

  eta <- 1
  eta_inc <- 1.5
  # gma <- log(seq(100,1,-0.05),2)
  gma <- log(seq(1,100,0.05),2)
  res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
  Lambda[[1]] <- res_ISTA_bktr[[1]]
  obj <- list(res_ISTA_bktr[[2]])

  for (i in 1:length(gma)) {
    res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[i]],Sigma,omega,gma[i+1],eta,eta_inc)
    Lambda[[i+1]] <- res_ISTA_bktr[[1]]
    obj[[i+1]] <- res_ISTA_bktr[[2]]
  
    if(nnzero(Lambda[[i+1]]) == n) break
  }
  df_t <- data.frame(lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)), init_id = rep(as.character(k),length(obj)))

  df <- rbind(df, df_t)
}
```

```{r}
# Obj
plt_1 <- ggplot(df,aes(x=gma,y=obj,color=init_id)) + 
  geom_line() + 
  labs(x="Gamma",y="Objective value")

plt_2 <- ggplot(df,aes(x=gma,y=obj,color=init_id)) + 
  geom_point() + 
  labs(x="Gamma",y="Objective value")

# # Wrong edges
# plt_3 <- ggplot(df_plt,aes(x=gma,y=err_edges,color=init)) + 
#   geom_line() + 
#   labs(x="Gamma",y="Number of wrong edges")
# 
# plt_4 <- ggplot(df_plt,aes(x=gma,y=err_edges,color=init)) + 
#   geom_point() + 
#   labs(x="Gamma",y="Number of wrong edges")

plt_1
plt_2
# plt_3
# plt_4
```
```{r}
# Convert df$lmd (list of matrices) into a long format, but keep init_id
df_long <- do.call(rbind, lapply(1:nrow(df), function(i) {
  Lambda_mat <- df$lmd[[i]]
  Lambda_melt <- melt(Lambda_mat)
  data.frame(
    row = Lambda_melt$Var1,
    col = Lambda_melt$Var2,
    value = Lambda_melt$value,
    gma = df$gma[i],
    init_id = df$init_id[i]
  )
}))

# Filter for the 7th initialization
# df_7 <- subset(df_long, init_id == "7")

# Filter out the diagonal entries
df_7 <- subset(df_long, init_id == "9" & row != col) 

# Plot entries of Lambda vs gamma for init_id = 7
ggplot(df_7, aes(x = gma, y = value, 
                 color = interaction(row, col), 
                 group = interaction(row, col))) +
  geom_line(alpha = 0.7) +
  labs(
    title = "Lambda entries vs Gamma (Initialization 9)",
    x = expression(gamma),
    y = "Lambda entry value",
    color = "Entry (row,col)"
  ) +
  theme_minimal()

```


# IHT

## Algo
n=3

```{r}
n <- 3
# Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)))
Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-t(Lambda_0) %x% t(Lambda_0)) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)
```

IHT with backtracking

```{r}
# IHT update with stepsize eta
ft_IHT_update <- function(Lambda_0,Sigma,omega,gma,eta) {
     grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_0[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
        }else if(grad_step < -sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else if (grad_step > sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}
```

```{r}
# Initialization
eta <- list(1) # Stepsize
eta_inc <- 1.05 # The increment of stepsize, a constant > 1
gma <- 0.05 # l1 penalty
obj <- list(1)
obj_gap <- list(1)

# Lambda <- list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
Lambda <-list(matrix(runif(n**2,-1,1),ncol=n))
# Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)
obj[[1]] <- frobenius.norm(Sigma - t(Lambda[[1]])%*%Sigma%*%Lambda[[1]] - omega * diag(n)) + gma * (sum(abs(c(Lambda[[1]]))>0)-n)

for (i in 1:10000) {
  for (l in 0:1000) {
    eta_t <- eta[[i]] / (eta_inc ** l)
    IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta_t)
    Lambda_updt <- IHT_updt[[1]]
    grad_updt <- IHT_updt[[2]]
    if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
      eta[[i+1]] <- eta_t
      break
    }
  }
  IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
  Lambda[[i+1]] <- IHT_updt[[1]]
  obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * (sum(abs(c(Lambda[[i+1]]))>0)-n)
  obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
  if(obj_gap[[i+1]] < 1e-6) {
    print("Converged.")
    break
  }
}

Lambda[[i+1]]
```
## Construct a chain of $\gamma$

ADMM
```{r}
ft_ADMM <- function(Sigma,omega,beta=0.5) {
  # Initialization
  Lambda_1 <- list(matrix(runif(n**2,-1,1),ncol=n))
  Lambda_2 <- list(matrix(runif(n**2,-1,1),ncol=n))
  alpha <- list(matrix(0,n,n))
  dis_1_2 <- list(1)
  obj <- list(1)
  
  for (i in 1:1000) {
    Lambda_1[[i+1]] <- solve(2*(Sigma %*% Lambda_2[[i]] %*% t(Lambda_2[[i]]) %*% Sigma) + beta * diag(n)) %*% (2*(Sigma %*% Lambda_2[[i]] %*% (Sigma - omega * diag(n))) - alpha[[i]] + beta * Lambda_2[[i]])
    Lambda_2[[i+1]] <- solve(2*Sigma %*% Lambda_1[[i+1]] %*% t(Lambda_1[[i+1]]) %*% Sigma + beta * diag(n)) %*% (2 * Sigma %*% Lambda_1[[i+1]] %*% (Sigma - omega * diag(n)) + alpha[[i]] + beta * Lambda_1[[i+1]])
    alpha[[i+1]] <- alpha[[i]] + beta * (Lambda_1[[i+1]] - Lambda_2[[i+1]])
    dis_1_2[[i+1]] <- frobenius.norm(Lambda_1[[i+1]] - Lambda_2[[i+1]])
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)) ** 2
  
  
    if(dis_1_2[[i+1]] < 1e-6 & obj[[i+1]] < 1e-6) {
      # print("ADMM succeeds!")
      return(list(Lambda_1[[i+1]],obj[[i+1]])) # Return the converged \Lambda and the objective function value
    }
  }
  print("ADMM did not converge after 1000 iterations.")
  return(list(Lambda_1[[i+1]],obj[[i+1]]))
}
```

IHT with backtracking

```{r}
# grad <- -4 * t((Sigma %*% Lambda_0) %*% (2*(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) -  diag(diag(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega*diag(n)))))

# ISTA update with stepsize eta
ft_IHT_update <- function(Lambda_0,Sigma,omega,gma,eta) {
     grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_0[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
        }else if(grad_step < -sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else if (grad_step > sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}

ft_IHT_bktr <- function(Lambda_0,Sigma,omega,gma,eta_0, eta_inc) {
  # eta_0 is the initial stepsize (before backtracking)
  eta <- list(eta_0)
  
  Lambda <- list(Lambda_0)
  obj <- list(frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) + gma * (sum(abs(c(Lambda_0)) >0)-n))
  obj_gap <- list(obj[[1]])
  
  for (i in 1:10000) {
    for (l in 0:1000) {
      eta_t <- eta[[i]] / (eta_inc ** l)
      IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta_t)
      Lambda_updt <- IHT_updt[[1]]
      grad_updt <- IHT_updt[[2]]
      if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
        eta[[i+1]] <- eta_t
        break
      }
    }
    IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
    Lambda[[i+1]] <- IHT_updt[[1]]
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * (sum(abs(c(Lambda[[i+1]]) )>0)-n)
    obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
    if(obj_gap[[i+1]] < 1e-6) {
      return(list(Lambda[[i+1]],obj[[i+1]]))
    }
  }
  print("IHT did not converge within 10000 iterations. Objective gap:")
  print(obj_gap[[i+1]])
  return(list(Lambda[[i+1]],obj[[i+1]]))
}
```

n=3

```{r}
n <- 3
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_0
Sigma
```

```{r}
beta <- 0.5
res_ADMM <- ft_ADMM(Sigma,omega, beta)
```

```{r}
# Lambda <- list(res_ADMM[[1]])
# Lambda <- list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
source("functions.R")
n <- 3
Lambda_0 <- Lambda_star[[3]]
omega <- 1
vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda <- list(matrix(runif(n**2,-1,1),n,n))
# Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)

eta <- 1
eta_inc <- 1.05
gma <- list(0)
res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
Lambda[[1]] <- res_IHT_bktr[[1]]
obj <- list(res_IHT_bktr[[2]])
err_edges <- list(sum((Lambda_0 != 0) != (Lambda[[1]] != 0)))

for (i in 1:100) {
  Lambda[[i+1]] <- Lambda[[i]]
  t_gma <- gma[[i]]
  while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
    t_gma <- t_gma + 0.01
    res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
    Lambda[[i+1]] <- res_IHT_bktr[[1]]
  }
  obj[[i+1]] <- res_IHT_bktr[[2]]
  gma[[i+1]] <- t_gma
  err_edges[[i+1]] <- sum((Lambda_0 != 0) != (Lambda[[i+1]] != 0))
  if(nnzero(Lambda[[i+1]]) == n) {
    print("Algorithm succeeds!")
    break
  }
}

gma
Lambda
obj
```

### Proportion of finding the true graph with random initialization

```{r}
num_exp <- 10
res_pos <- 0

eta <- 1
eta_inc <- 1.05

for (j in 1:num_exp) {
  Lambda <- list(matrix(runif(n**2,-1,1),n,n))
  gma <- list(0)
  res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
  Lambda[[1]] <- res_IHT_bktr[[1]]
  obj <- list(res_IHT_bktr[[2]])
  err_edges <- list(sum((Lambda_0 != 0) != (Lambda[[1]] != 0)))
  err_edges_t <- list(sum((Lambda_0 != 0) != (t(Lambda[[1]]) != 0)))

  for (i in 1:100) {
    Lambda[[i+1]] <- Lambda[[i]]
    t_gma <- gma[[i]]
    while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
      t_gma <- t_gma + 0.01
      res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
      Lambda[[i+1]] <- res_IHT_bktr[[1]]
    }
    obj[[i+1]] <- res_IHT_bktr[[2]]
    gma[[i+1]] <- t_gma
    err_edges[[i+1]] <- sum((Lambda_0 != 0) != (Lambda[[i+1]] != 0))
    err_edges_t[[i+1]] <- sum((Lambda_0 != 0) != (t(Lambda[[i+1]]) != 0))
    if(nnzero(Lambda[[i+1]]) == n) {
      break
    }
  }
  
  if (0 %in% err_edges) {
    res_pos <- res_pos+1
  }
}

print(res_pos / num_exp)
```



## Grid of \gamma

```{r}
# Lambda <- list(res_ADMM[[1]])
# Lambda <- list(rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1))))
Lambda <- list(matrix(runif(n**2,-1,1),n,n))
# Lambda <- list(Lambda[[1]])
# Lambda <- list(matrix(runif(n**2,-0.01,0.01),n,n) + Lambda_0)

eta <- 1
eta_inc <- 1.05
gma <- seq(0,10,0.01)
res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[1],eta,eta_inc)
Lambda[[1]] <- res_IHT_bktr[[1]]
obj <- list(res_IHT_bktr[[2]])
err_edges <- list(sum((Lambda_0 != 0) != (Lambda[[1]] != 0)))

for (i in 1:length(gma)) {
  res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,gma[i+1],eta,eta_inc)
  Lambda[[i+1]] <- res_IHT_bktr[[1]]
  obj[[i+1]] <- res_IHT_bktr[[2]]
  err_edges[[i+1]] <- sum((Lambda_0 != 0) != (Lambda[[i+1]] != 0))
  
  if(nnzero(Lambda[[i+1]]) == n) {
    print(i)
    print(0 %in% err_edges)
    break
  }
}
```

```{r}
df <- data.frame(lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)), err_edges = array(unlist(err_edges)), init = rep("Pos_1",length(obj)))
```

```{r}
#df_t <- data.frame(lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)), err_edges = array(unlist(err_edges)), init = rep("DIAG",length(obj)))
#df_t <- data.frame(lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)), err_edges = array(unlist(err_edges)), init = rep("RAND",length(obj)))
df_t <- data.frame(lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)), err_edges = array(unlist(err_edges)), init = rep("nPos_2",length(obj)))

df <- rbind(df, df_t)
```

```{r}
# Obj
plt_1 <- ggplot(df,aes(x=gma,y=obj,color=init)) + 
  geom_line() + 
  labs(x="Gamma",y="Objective value")

plt_2 <- ggplot(df,aes(x=gma,y=obj,color=init)) + 
  geom_point() + 
  labs(x="Gamma",y="Objective value")

# Wrong edges
plt_3 <- ggplot(df,aes(x=gma,y=err_edges,color=init)) + 
  geom_line() + 
  labs(x="Gamma",y="Number of wrong edges")

plt_4 <- ggplot(df,aes(x=gma,y=err_edges,color=init)) + 
  geom_point() + 
  labs(x="Gamma",y="Number of wrong edges")

plt_1
plt_2
plt_3
plt_4
```


# Sol1: IHT+ADMM+Grid search

ADMM with given support
```{r}
ADMM_supp <- function(Sigma,omega,Lambda_t,beta=0.5) {
  for (j in 1:5) {
    # Initialization
    Lambda_1 <- list(matrix(runif(n**2,-1,1),ncol=n))
    Lambda_2 <- list(matrix(runif(n**2,-1,1),ncol=n))
    alpha <- list(matrix(0,n,n))
    dis_1_2 <- list(1)
    obj <- list(1)
  
    for (i in 1:1000) {
      Lambda_1[[i+1]] <- solve(2*(Sigma %*% Lambda_2[[i]] %*% t(Lambda_2[[i]]) %*% Sigma) + beta * diag(n)) %*% (2*(Sigma %*% Lambda_2[[i]] %*% (Sigma - omega * diag(n))) - alpha[[i]] + beta * Lambda_2[[i]])
      Lambda_2[[i+1]] <- solve(2*Sigma %*% Lambda_1[[i+1]] %*% t(Lambda_1[[i+1]]) %*% Sigma + beta * diag(n)) %*% (2 * Sigma %*% Lambda_1[[i+1]] %*% (Sigma - omega * diag(n)) + alpha[[i]] + beta * Lambda_1[[i+1]])
      Lambda_1[[i+1]][Lambda_t == 0] <- 0
      Lambda_2[[i+1]][Lambda_t == 0] <- 0
      alpha[[i+1]] <- alpha[[i]] + beta * (Lambda_1[[i+1]] - Lambda_2[[i+1]])
      dis_1_2[[i+1]] <- frobenius.norm(Lambda_1[[i+1]] - Lambda_2[[i+1]])
      obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)) ** 2
  
  
      if(dis_1_2[[i+1]] < 1e-6 & obj[[i+1]] < 1e-6) {
        return(TRUE) # Return the converged \Lambda and the objective function value
      }
    }
  }
  return(FALSE)
}
```


IHT with backtracking
```{r}
# grad <- -4 * t((Sigma %*% Lambda_0) %*% (2*(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) -  diag(diag(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega*diag(n)))))

# IHT update with stepsize eta
ft_IHT_update <- function(Lambda_0,Sigma,omega,gma,eta) {
     grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    Lambda_updt <- matrix(0,n,n)
    for (j in 1:n) {
      for(k in 1:n) {
        grad_step <- Lambda_0[j,k] - eta * grad[j,k]
      if (j == k) {
        Lambda_updt[j,k] <- grad_step
        }else if(grad_step < -sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else if (grad_step > sqrt(2*eta*gma)) {
          Lambda_updt[j,k] <- grad_step
        }else {
          Lambda_updt[j,k] <- 0
        }
      }
    }
    return (list(Lambda_updt,grad))
}

ft_IHT_bktr <- function(Lambda_0,Sigma,omega,gma,eta_0, eta_inc) {
  # eta_0 is the initial stepsize (before backtracking)
  eta <- list(eta_0)
  
  Lambda <- list(Lambda_0)
  obj <- list(frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) + gma * (sum(abs(c(Lambda_0)) >0)-n))
  obj_gap <- list(obj[[1]])
  
  for (i in 1:10000) {
    for (l in 0:1000) {
      eta_t <- eta[[i]] / (eta_inc ** l)
      IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta_t)
      Lambda_updt <- IHT_updt[[1]]
      grad_updt <- IHT_updt[[2]]
      if(frobenius.norm(Sigma - t(Lambda_updt)%*%Sigma%*%Lambda_updt - omega * diag(n)) > frobenius.norm(Sigma - t(Lambda[[i]])%*%Sigma%*%Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt-Lambda[[i]])**2) / (2*eta_t)){}else{
        eta[[i+1]] <- eta_t
        break
      }
    }
    IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
    Lambda[[i+1]] <- IHT_updt[[1]]
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * (sum(abs(c(Lambda[[i+1]]) )>0)-n)
    obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
    if(obj_gap[[i+1]] < 1e-6) {
      return(list(Lambda[[i+1]],obj[[i+1]]))
    }
  }
  print("IHT did not converge within 10000 iterations. Objective gap:")
  print(obj_gap[[i+1]])
  return(list(Lambda[[i+1]],obj[[i+1]]))
}
```

Function of constructing a chain using IHT
```{r}
IHT_chain <- function(Lambda_0,Sigma,omega,eta,eta_inc) {
  Lambda <- list(Lambda_0)
  gma <- list(0)
  res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
  Lambda[[1]] <- res_IHT_bktr[[1]]
  # obj <- list(res_IHT_bktr[[2]])
  
  for (i in 1:100) {
    Lambda[[i+1]] <- Lambda[[i]]
    t_gma <- gma[[i]]
    while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
      t_gma <- t_gma + 0.01
      res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
      Lambda[[i+1]] <- res_IHT_bktr[[1]]
    }
    # obj[[i+1]] <- res_IHT_bktr[[2]]
    gma[[i+1]] <- t_gma
    if(nnzero(Lambda[[i+1]]) == n) {
      return(Lambda)
    }
  }
}
```

Initialization
```{r}
n <- 3
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
Lambda_0 <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(0,0,runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(0,runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),0,runif(1,-1,1)))

# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(0,runif(1,-1,1),runif(1,-1,1)))
# Lambda_0 <- rbind(c(runif(1,-1,1),runif(1,-1,1),runif(1,-1,1)),c(runif(1,-1,1),runif(1,-1,1),0),c(runif(1,-1,1),0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_0
Sigma
```

```{r}
# n=4
n <- 4
Lambda_supp <- rbind(c(1,0,0,1),c(0,1,0,1),c(0,0,1,1),c(0,0,0,1))

Lambda_0 <- matrix(0,n,n)
Lambda_0[Lambda_supp != 0] <- runif(sum(abs(c(Lambda_supp) )>0),-1,1)

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_0
Sigma
``` 


Construct a list of possible graphs with smallest number of edges
```{r}
start <- Sys.time() # Track the running time

l <- 100 # Number of different initializations
eta <- 1
eta_inc <- 1.05

Lambda_init <- replicate(l,matrix(runif(n**2,-1,1),n,n),simplify = FALSE)
Lambda_cand <- list()

for (i in 1:l) {
  Lambda_t <- IHT_chain(Lambda_init[[i]],Sigma,omega,eta,eta_inc)
  for (k in seq(length(Lambda_t)-1,1,-1)) {
    if(ADMM_supp(Sigma,omega,Lambda_t[[k]])) {
      Lambda_cand[[i]] <- Lambda_t[[k]]
      break
    }
  }
}

print(Sys.time() - start)
```

```{r}
df_res <- data.frame(I(Lambda_init), I(Lambda_cand), graph = I(lapply(Lambda_cand,function(mat) abs(mat)>0)),num_edges = array(unlist(lapply(Lambda_cand,function(mat) sum(abs(c(mat))>0) - n))))

df_res <- df_res[df_res$num_edges == min(df_res$num_edges),]
df_res <- df_res[!duplicated(df_res$num_edges), ]

if(nrow(df_res) > 1) {
  print("A grid search is needed.")
}else {
  print("The graph found by the algorithm is:")
  print(df_res$graph)
}
```
In the case of grid search:

```{r}
df_grid <- data.frame(id = numeric(), lmd = I(list()), gma = numeric(), obj = numeric())

for (k in nrow(df_res)) {
  eta <- 1
  eta_inc <- 1.05
  gma <- seq(0,10,0.01)
  Lambda <- list(df_res$Lambda_init[[k]])
  res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[1],eta,eta_inc)
  Lambda[[1]] <- res_IHT_bktr[[1]]
  obj <- list(res_IHT_bktr[[2]])

  for (i in 1:length(gma)) {
    res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,gma[i+1],eta,eta_inc)
    Lambda[[i+1]] <- res_IHT_bktr[[1]]
    obj[[i+1]] <- res_IHT_bktr[[2]]
  
    if(nnzero(Lambda[[i+1]]) == n) {
      break
    }
  }
  
  df_t <- data.frame(id = rep(k,length(obj)), lmd = array(Lambda), gma = gma[1:length(obj)], obj = array(unlist(obj)))
  df_grid <- rbind(df_grid,df_t)
}
```

```{r}
# Obj
plt_1 <- ggplot(df_grid,aes(x=gma,y=obj,color=id)) + 
  geom_line() + 
  labs(x="Gamma",y="Objective value")

plt_2 <- ggplot(df_grid,aes(x=gma,y=obj,color=id)) + 
  geom_point() + 
  labs(x="Gamma",y="Objective value")

plt_1
plt_2
```


# Sol2: ADMM + ISTA



































# Exhaustive search

n=4

```{r}
n <- 4
# Lambda_0 <- rbind(c(runif(1,-1,1),0,0),c(0,runif(1,-1,1),0),c(0,0,runif(1,-1,1)))
Lambda_0 <- rbind(c(runif(1,-1,1),0,0,0),c(0,runif(1,-1,1),0,0),c(0,0,runif(1,-1,1),0),c(0,0,0,runif(1,-1,1)))
edge_ind <- setdiff(1:(n**2),seq(1,n**2,n+1))
edge_real <- combn(edge_ind,4)
Lambda_0[edge_real[,211]] <- runif(4,-1,1)

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_0
Sigma
```

ADMM
```{r}
beta <- 0.5
Lambda_1 <- list(matrix(runif(n**2,-1,1),ncol=n))
Lambda_2 <- list(matrix(runif(n**2,-1,1),ncol=n))
Lambda_t <- Lambda_0
alpha <- list(matrix(0,n,n))
dis_1_2 <- list(1)
obj <- list(1)
  
for (i in 1:1000) {
  Lambda_1[[i+1]] <- solve(2*(Sigma %*% Lambda_2[[i]] %*% t(Lambda_2[[i]]) %*% Sigma) + beta * diag(n)) %*% (2*(Sigma %*% Lambda_2[[i]] %*% (Sigma - omega * diag(n))) - alpha[[i]] + beta * Lambda_2[[i]])
  Lambda_2[[i+1]] <- solve(2*Sigma %*% Lambda_1[[i+1]] %*% t(Lambda_1[[i+1]]) %*% Sigma + beta * diag(n)) %*% (2 * Sigma %*% Lambda_1[[i+1]] %*% (Sigma - omega * diag(n)) + alpha[[i]] + beta * Lambda_1[[i+1]])
  Lambda_1[[i+1]][Lambda_t == 0] <- 0
  Lambda_2[[i+1]][Lambda_t == 0] <- 0
  alpha[[i+1]] <- alpha[[i]] + beta * (Lambda_1[[i+1]] - Lambda_2[[i+1]])
  dis_1_2[[i+1]] <- frobenius.norm(Lambda_1[[i+1]] - Lambda_2[[i+1]])
  obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)) ** 2
  
  
  if(dis_1_2[[i+1]] < 1e-6 & obj[[i+1]] < 1e-6) {
    print("ADMM succeeds!")
    break
  }
}

Lambda_1[[1]]
Lambda_1[[i+1]]
Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)
obj[[i+1]]
```

## Greedy algorithm

ADMM with given support
```{r}
ADMM_supp <- function(Sigma,omega,Lambda_t,beta=0.5) {
  for (j in 1:5) {
    # Initialization
    Lambda_1 <- list(matrix(runif(n**2,-1,1),ncol=n))
    Lambda_2 <- list(matrix(runif(n**2,-1,1),ncol=n))
    alpha <- list(matrix(0,n,n))
    dis_1_2 <- list(1)
    obj <- list(1)
  
    for (i in 1:1000) {
      Lambda_1[[i+1]] <- solve(2*(Sigma %*% Lambda_2[[i]] %*% t(Lambda_2[[i]]) %*% Sigma) + beta * diag(n)) %*% (2*(Sigma %*% Lambda_2[[i]] %*% (Sigma - omega * diag(n))) - alpha[[i]] + beta * Lambda_2[[i]])
      Lambda_2[[i+1]] <- solve(2*Sigma %*% Lambda_1[[i+1]] %*% t(Lambda_1[[i+1]]) %*% Sigma + beta * diag(n)) %*% (2 * Sigma %*% Lambda_1[[i+1]] %*% (Sigma - omega * diag(n)) + alpha[[i]] + beta * Lambda_1[[i+1]])
      Lambda_1[[i+1]][Lambda_t == 0] <- 0
      Lambda_2[[i+1]][Lambda_t == 0] <- 0
      alpha[[i+1]] <- alpha[[i]] + beta * (Lambda_1[[i+1]] - Lambda_2[[i+1]])
      dis_1_2[[i+1]] <- frobenius.norm(Lambda_1[[i+1]] - Lambda_2[[i+1]])
      obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda_1[[i+1]]) %*% Sigma %*% Lambda_2[[i+1]] - omega * diag(n)) ** 2
  
  
      if(dis_1_2[[i+1]] < 1e-6 & obj[[i+1]] < 1e-6) {
        return(list(TRUE,Lambda_1[[1]],Lambda_1[[i+1]],obj[[i+1]])) # Return the converged \Lambda and the objective function value
      }
    }
  }
  return(list(FALSE,Lambda_1[[i+1]],obj[[i+1]]))
}
```

```{r}
start <- Sys.time()

# for (j in seq(ncol(edge_cand),1,-1)) {
# List of indices of possible edges
edge_ind <- setdiff(1:(n**2),seq(1,n**2,n+1))

for (i in 1:length(edge_ind)) {
  edge_cand <- combn(edge_ind,i)
  for (j in seq(ncol(edge_cand),1,-1)) {
    Lambda_t <- diag(n)
    Lambda_t[edge_cand[,j]] <- 1
    res_ADMM_supp <- ADMM_supp(Sigma,omega,Lambda_t)
    if(res_ADMM_supp[[1]]) {
      if(all((res_ADMM_supp[[3]]!=0) == (Lambda_0!=0))) {
        print("Greedy algorithm succeed!")
      }
      print(res_ADMM_supp)
      break
    }
  }
  if(res_ADMM_supp[[1]]) {
    break
  }
}

print(Sys.time() - start)
```




```{r}
n <- 5
# Lambda <- rbind(c(0.7,0.9,0,0,0), c(0.3,0.8,0.9,0,0),c(0,0.5,0.4,-0.6,0),c(0,0,0.76,0.9,0.65), c(0,0,0,0.8,0.5))
Lambda <- rbind(c(0.03,0,0.8,0,0),c(0,0.05,0.04,0,0),c(0.07,-0.09,0.06,0.03,0.04),c(0,0,-0.65,0.09,0), c(0,0,0.08,0,0.05)) 
omega <- 1

# Calculate Sigma
vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

f_Sigma <- c()
num_edge <- nnzero(Lambda)

for (i in 1:100) {
  Lambda_val <- runif(num_edge,-1,1)
  Lambda_t <- rbind(c(Lambda_val[1],Lambda_val[2],0,0,0), c(Lambda_val[3],Lambda_val[4],Lambda_val[5],0,0),c(0,Lambda_val[6],Lambda_val[7],-Lambda_val[8],0),c(0,0,Lambda_val[9],Lambda_val[10],Lambda_val[11]), c(0,0,0,Lambda_val[12],Lambda_val[13]))
  f_Sigma_val <- frobenius.norm(Sigma - t(Lambda_t) %*% Sigma %*% Lambda_t - diag(n))
  f_Sigma <- c(f_Sigma,f_Sigma_val)
}

plot(1:100,f_Sigma)
```

# Summary

## Accuracy: ISTA & IHT

### Functions

IHT

```{r}
# grad <- -4 * t((Sigma %*% Lambda_0) %*% (2*(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) -  diag(diag(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega*diag(n)))))

# ISTA update with stepsize eta
ft_IHT_update <- function(Lambda_0,Sigma,omega,gma,eta) {
     grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    grad_step <- Lambda_0 - eta * grad
    Lambda_updt <- grad_step
    
    mask_diag <- diag(n) == 1        # diagonal entries
    mask_off <- !mask_diag
    
    mask_keep <- abs(grad_step) > sqrt(2 * eta * gma)
    Lambda_updt[mask_off & !mask_keep] <- 0
    
    return (list(Lambda_updt,grad))
}

ft_IHT_bktr <- function(Lambda_0,Sigma,omega,gma,eta_0, eta_inc) {
  # eta_0 is the initial stepsize (before backtracking)
  eta <- list(eta_0)
  
  Lambda <- list(Lambda_0)
  obj <- list(frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) + gma * (sum(abs(c(Lambda_0)) >0)-n))
  obj_gap <- list(obj[[1]])
  
  for (i in 1:1000) {
    eta_t <- eta[[i]]
    l <- 1
    repeat {
      IHT_updt <- ft_IHT_update(Lambda[[i]], Sigma, omega, gma, eta_t)
      Lambda_updt <- IHT_updt[[1]]
      grad_updt <- IHT_updt[[2]]
  
      lhs <- frobenius.norm(Sigma - t(Lambda_updt) %*% Sigma %*% Lambda_updt - omega * diag(n))
      rhs <- frobenius.norm(Sigma - t(Lambda[[i]]) %*% Sigma %*% Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt - Lambda[[i]])^2) / (2*eta_t)
  
      if (lhs <= rhs) break
      eta_t <- eta_t / eta_inc
      
      l <- l+1
      if(l > 1000) break
    }
    eta[[i+1]] <- eta_t
    
    IHT_updt <- ft_IHT_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
    Lambda[[i+1]] <- IHT_updt[[1]]
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * (sum(abs(c(Lambda[[i+1]]) )>0)-n)
    obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
    if(obj_gap[[i+1]] < 1e-6) {
      return(list(Lambda[[i+1]],obj[[i+1]],TRUE))
    }
  }
  # print("IHT did not converge within 1000 iterations. Objective gap:")
  # print(obj_gap[[i+1]])
  return(list(Lambda[[i+1]],obj[[i+1]],FALSE))
}
```

```{r}
get_prop_IHT <- function (n,Sigma, omega, Lambda_0, num_exp, eta, eta_inc) {
  res_pos <- 0
  
  for (j in 1:num_exp) {
    Lambda <- list(matrix(runif(n**2,-1,1),n,n))
    gma <- list(0)
    err_edges <- integer(0)
    res_IHT_bktr <- ft_IHT_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
    #if(!res_IHT_bktr[[3]]){
    #  return(list(res_pos / num_exp,FALSE))
    #}
    Lambda[[1]] <- res_IHT_bktr[[1]]
    err_edges[1] <- sum(xor(Lambda_0 != 0, Lambda[[1]] != 0))

    i <- 1
    repeat {
      Lambda[[i+1]] <- Lambda[[i]]
      t_gma <- gma[[i]]
      while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
        t_gma <- t_gma + 0.01
        res_IHT_bktr <- ft_IHT_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
        # if(!res_IHT_bktr[[3]]){
        #  return(list(res_pos / num_exp,FALSE))
        #}
        Lambda[[i+1]] <- res_IHT_bktr[[1]]
      }
      gma[[i+1]] <- t_gma
      err_edges[i+1] <- sum(xor(Lambda_0 != 0, Lambda[[i+1]] != 0))
      if(nnzero(Lambda[[i+1]]) == n)  break
      i <- i+1
    }
  
    if (0 %in% err_edges) {
      res_pos <- res_pos+1
    }
  }
  
  return(list(res_pos / num_exp,TRUE))
}
```

ISTA
```{r}
# grad <- -4 * t((Sigma %*% Lambda_0) %*% (2*(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) -  diag(diag(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega*diag(n)))))

# ISTA update with stepsize eta
ft_ISTA_update <- function(Lambda_0,Sigma,omega,gma,eta) {
    grad <- grad <- -2 * ((Sigma %*% Lambda_0) %*% (Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))) / frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n))
    grad_step <- Lambda_0 - eta * grad
    Lambda_updt <- grad_step
    
    mask_diag <- diag(n) == 1
    Lambda_updt[!mask_diag & grad_step < -eta*gma] <- grad_step[!mask_diag & grad_step < -eta*gma] + eta*gma
    Lambda_updt[!mask_diag & grad_step >  eta*gma] <- grad_step[!mask_diag & grad_step >  eta*gma] - eta*gma
    Lambda_updt[!mask_diag & abs(grad_step) <= eta*gma] <- 0
    
    return (list(Lambda_updt,grad))
}

ft_ISTA_bktr <- function(Lambda_0,Sigma,omega,gma,eta_0, eta_inc) {
  # eta_0 is the initial stepsize (before backtracking)
  eta <- list(eta_0)
  
  Lambda <- list(Lambda_0)
  obj <- list(frobenius.norm(Sigma - t(Lambda_0)%*%Sigma%*%Lambda_0 - omega * diag(n)) + gma * sum(abs(c(Lambda_0) - c(diag(diag(Lambda_0))))))
  obj_gap <- list(obj[[1]])
  
  for (i in 1:1000) {
    eta_t <- eta[[i]]
    l <- 1
    repeat {
      ISTA_updt <- ft_ISTA_update(Lambda[[i]], Sigma, omega, gma, eta_t)
      Lambda_updt <- ISTA_updt[[1]]
      grad_updt <- ISTA_updt[[2]]
  
      lhs <- frobenius.norm(Sigma - t(Lambda_updt) %*% Sigma %*% Lambda_updt - omega * diag(n))
      rhs <- frobenius.norm(Sigma - t(Lambda[[i]]) %*% Sigma %*% Lambda[[i]] - omega * diag(n)) + sum((Lambda_updt - Lambda[[i]]) * grad_updt) + (frobenius.norm(Lambda_updt - Lambda[[i]])^2) / (2*eta_t)
  
      if (lhs <= rhs) break
      eta_t <- eta_t / eta_inc
      
      l <- l+1
      if(l>1000) break
    }
    eta[[i+1]] <- eta_t
    
    ISTA_updt <- ft_ISTA_update(Lambda[[i]],Sigma,omega,gma,eta[[i+1]])
    Lambda[[i+1]] <- ISTA_updt[[1]]
    obj[[i+1]] <- frobenius.norm(Sigma - t(Lambda[[i+1]])%*%Sigma%*%Lambda[[i+1]] - omega * diag(n)) + gma * sum(abs(c(Lambda[[i+1]]) - c(diag(diag(Lambda[[i+1]])))))
    obj_gap[[i+1]] <- abs(obj[[i+1]] - obj[[i]])
    
    if(obj_gap[[i+1]] < 1e-4) {
      return(list(Lambda[[i+1]],obj[[i+1]],TRUE))
    }
  }
  #print("ISTA did not converge within 10000 iterations. Objective gap:")
  #print(obj_gap[[i+1]])
  return(list(Lambda[[i+1]],obj[[i+1]],FALSE))
}
```

```{r}
get_prop_ISTA <- function (n,Sigma, omega, Lambda_0, num_exp, eta, eta_inc) {
  res_pos <- 0
  res_pos_t <- 0
  
  for (j in 1:num_exp) {
    Lambda <- list(matrix(runif(n**2,-1,1),n,n))
    gma <- list(0)
    err_edges <- integer(0)
    err_edges_t <- integer(0)
    res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[1]],Sigma,omega,gma[[1]],eta,eta_inc)
    # if(!res_ISTA_bktr[[3]]){
    #  return(list(res_pos / num_exp,FALSE))
    # }
    Lambda[[1]] <- res_ISTA_bktr[[1]]
    err_edges[1] <- sum(xor(Lambda_0 != 0, Lambda[[1]] != 0))
    err_edges_t[1] <- sum(xor(t(Lambda_0) != 0, Lambda[[1]] != 0))

    for (i in 1:10000) {
      Lambda[[i+1]] <- Lambda[[i]]
      t_gma <- gma[[i]]
      while (all((Lambda[[i]]!=0) == (Lambda[[i+1]]!=0))) {
        t_gma <- t_gma + 0.01
        res_ISTA_bktr <- ft_ISTA_bktr(Lambda[[i]],Sigma,omega,t_gma,eta,eta_inc)
        # if(!res_ISTA_bktr[[3]]){
        #  return(list(res_pos / num_exp,FALSE))
        # }
        Lambda[[i+1]] <- res_ISTA_bktr[[1]]
      }
      gma[[i+1]] <- t_gma
      err_edges[i+1] <- sum(xor(Lambda_0 != 0, Lambda[[i+1]] != 0))
      err_edges_t[i+1] <- sum(xor(t(Lambda_0) != 0, Lambda[[i+1]] != 0))
      if(nnzero(Lambda[[i+1]]) == n) {
        break
      }
    }
  
    if (0 %in% err_edges) {
      res_pos <- res_pos+1
    }else if (0 %in% err_edges_t) {
      res_pos_t <- res_pos_t+1
    }
  }
  
  return(list(res_pos / num_exp,res_pos_t / num_exp,TRUE))
}
```

### Box plot
```{r}
df <- data.frame(n = numeric(), algo = character(), prop = numeric())
Lambda_init <- list()
```


```{r}
num_exp <- 10

# n=3
n <- 3
Lambda_supp <- rbind(c(1,0,1),c(0,1,1),c(0,0,1))


start <- Sys.time()

i<-1 
while (i<=25) {
  print(i)
  Lambda_0 <- matrix(0,n,n)
  Lambda_0[Lambda_supp != 0] <- runif(sum(abs(c(Lambda_supp))>0),-1,1)

  omega <- 1

  vec_Sigma <- solve(diag(n**2)-(t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
  Sigma <- matrix(vec_Sigma, nrow = n)
  
  res_IHT_prop <- get_prop_IHT(n,Sigma, omega, Lambda_0, num_exp, 1, 1.05)
  res_ISTA_prop <- get_prop_ISTA(n,Sigma, omega, Lambda_0, num_exp, 1, 1.05)
  # if(res_IHT_prop[[2]]) {
    df_IHT <- data.frame(n=n,algo="IHT",prop=res_IHT_prop[[1]])
    df_ISTA <- data.frame(n=n,algo="ISTA",prop=res_ISTA_prop[[1]])
    df_ISTA_t <- data.frame(n=n,algo="ISTA_t",prop=res_ISTA_prop[[2]])
    df <- rbind(df,df_IHT,df_ISTA,df_ISTA_t)
    Lambda_init[[i]] <- Lambda_0
    i <- i+1
  # }
}

print(Sys.time() - start)
```

Use multiple workers
```{r}
library(future.apply)
library(progressr)
```

```{r}
# set up parallel plan (multisession is safest in RStudio)
plan(multisession, workers = parallel::detectCores() - 1)

n <- 3
Lambda_supp <- rbind(c(1,0,1),
                     c(0,1,1),
                     c(0,0,1))

num_exp <- 10   # keep small just for testing speedup
num_init <- 25

with_progress({
  p <- progressor(along = 1:num_init)   

  results <- future_lapply(1:num_init, function(i) {
    # construct one random initialization
    Lambda_0 <- matrix(0, n, n)
    Lambda_0[Lambda_supp != 0] <- runif(sum(Lambda_supp != 0), -1, 1)
    omega <- 1

    vec_Sigma <- solve(diag(n^2) - (t(Lambda_0) %x% t(Lambda_0))) %*% vec(omega * diag(n))
    Sigma <- matrix(vec_Sigma, nrow = n)

    res_IHT_prop  <- get_prop_IHT(n, Sigma, omega, Lambda_0, num_exp, 1, 1.05)
    res_ISTA_prop <- get_prop_ISTA(n, Sigma, omega, Lambda_0, num_exp, 1, 1.05)

    # update progress
    p()

    # return results
    list(
      Lambda_0 = Lambda_0,
      res = list(
        data.frame(n=n, algo="IHT",    prop=res_IHT_prop[[1]], init_id = i),
        data.frame(n=n, algo="ISTA",   prop=res_ISTA_prop[[1]], init_id = i),
        data.frame(n=n, algo="ISTA_t", prop=res_ISTA_prop[[2]], init_id = i)
      )
  )
  }, future.seed = TRUE)
})


# combine results into one data frame and record the initializations
Lambda_star <- lapply(results, `[[`, "Lambda_0")
df_t <- do.call(rbind, unlist(lapply(results, `[[`, "res"), recursive=FALSE))

save(Lambda_star,df_t,file="res_3_25.RData")
```

```{r}
partial_files <- list.files("partial_result", pattern = "partial_result_.*\\.rds$", full.names = TRUE)
all_results <- lapply(partial_files, readRDS)

df_t <- do.call(rbind, unlist(lapply(all_results, `[[`, "res"), recursive = FALSE))
Lambda_star_t <- lapply(all_results, `[[`, "Lambda_0")

# df <- rbind(df,df_t[,-4])
# Lambda_star <- c(Lambda_star,Lambda_star_t)
df <- df_t
Lambda_star <- Lambda_star_t

save(df,Lambda_star,file="res_10_4.RData")
```

```{r}
plt <- ggplot(df,aes(algo,prop)) + geom_boxplot(fill = "dodgerblue1", colour = "black", alpha = 0.5, outlier.colour = "tomato2") + 
  labs(
    x = "Algorithm",
    y = "Proportion of success",
    title = "n=10"
  )


plt
```

## ROC
```{r}
compare_rocs <- function(n, Sigma, omega,Lambda_0, Lambda_inits,gma_cand=log10(seq(100,1,-0.1)), eta=1, eta_inc=1.05) {
  results <- list()
  
  for (j in seq_along(Lambda_inits)) {
    cat("Running init", j, "...\n")
    
    roc_res <- get_roc_ISTA(
      n = n,
      Sigma = Sigma,
      omega = omega,
      Lambda_0 = Lambda_0,
      Lambda_init = Lambda_inits[[j]],
      gma_cand = gma_cand,
      eta = eta,
      eta_inc = eta_inc
    )
    
    results[[j]] <- list(
      init_id = paste0("init_", j),
      TPR = roc_res[[1]],
      FPR = roc_res[[2]],
      TPR_t = roc_res[[3]],
      FPR_t = roc_res[[4]]
    )
  }
  
  return(results)
}
```

```{r}
gma_cand <- log(seq(1,100,0.05),2)
Lambda_0 <- Lambda_star[[9]]
# load("Lambda_init_9.RData")

all_rocs <- compare_rocs(n, Sigma, omega,Lambda_0, Lambda_init,gma_cand)

roc_df <- do.call(rbind, lapply(seq_along(all_rocs), function(j) {
  data.frame(
    init_id = all_rocs[[j]]$init_id,
    TPR = all_rocs[[j]]$TPR,
    FPR = all_rocs[[j]]$FPR,
    TPR_t = all_rocs[[j]]$TPR_t,
    FPR_t = all_rocs[[j]]$FPR_t
  )
}))

```

```{r}
roc_df <- do.call(rbind, lapply(seq_along(all_rocs), function(j) {
  data.frame(
    init_id = all_rocs[[j]]$init_id,
    FPR = all_rocs[[j]]$FPR,
    TPR = all_rocs[[j]]$TPR
  )
}))

# --- Plot ROC curves ---
library(ggplot2)

ggplot(roc_df[nrow(roc_df):1,], aes(x = FPR, y = TPR, color = init_id)) +
  geom_line(size = 1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(title = "ROC Curves across Lambda_inits",
       x = "False Positive Rate (FPR)",
       y = "True Positive Rate (TPR)",
       color = "Initialization") +
  theme_minimal()
```


```{r}
partial_files <- list.files("partial_result", pattern = "partial_result_.*\\.rds$", full.names = TRUE)
all_results <- lapply(partial_files, readRDS)

df_t <- do.call(rbind, unlist(lapply(all_results, `[[`, "res"), recursive = FALSE))

# df <- rbind(df,df_t)
df <- df_t

save(df,Lambda_star,file="res_3_8.RData")
```

```{r}
df <- df_t
df_filtered <- df %>%
  group_by(algo, FPR) %>%
  slice_max(order_by = TPR, n = 1, with_ties = FALSE) %>%
  ungroup()

plt <- ggplot(df_filtered, aes(x = FPR, y = TPR, color = algo, group = algo)) +
  geom_line() +
  geom_point(size = 2) +         # add points
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
  labs(x = "False Positive Rate", 
       y = "True Positive Rate", 
       color = "Algorithm") +
  theme_minimal(base_size = 14)

plt
```

```{r}
df_clean <- na.omit(df)
plt_TPR <- ggplot(df_clean,aes(algo,TPR)) + geom_boxplot(fill = "dodgerblue1", colour = "black", alpha = 0.5, outlier.colour = "tomato2") + 
  labs(
    x = "Algorithm",
    y = "True positive rate",
    title = "n=3"
  )

plt_FPR <- ggplot(df_clean,aes(algo,FPR)) + geom_boxplot(fill = "dodgerblue1", colour = "black", alpha = 0.5, outlier.colour = "tomato2") + 
  labs(
    x = "Algorithm",
    y = "False positive rate",
    title = "n=3"
  )


plt_TPR
plt_FPR
```















# Other blocks

```{r}
n <- 3
# Lambda <- rbind(runif(3,0.1,1),c(0,runif(1,0.1,1),0),c(0,0,runif(1,0.1,1)))  # Changable coefficients
Lambda <- rbind(c(runif(1,0.1,1),0,runif(1,0.1,1)),c(0,runif(2,0.1,1)),c(0,0,runif(1,0.1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gamma) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],par[3]),c(par[4],par[5],par[6]),c(par[7],par[8],par[9]))
  non_zero_par <- c(Lambda[-c(1,5,9)])
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2") ** 2 + abs(gamma * sum(abs(non_zero_par)))
  return (obj)
}

gamma_par <- 1
res <- optim(par=c(runif(9,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
while(1) {
  while (res$convergence) {
    res <- optim(par=c(runif(9,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  }
  off_diag_par <- length(which(abs(res$par[-c(1,5,9)]) > 0.01))
  if (off_diag_par == 2) {
    print(gamma_par)
    break
  }else if(off_diag_par < 2){
   gamma_par <<- gamma_par - 1
  }else {
    gamma_par <<- gamma_par + 1
  }
}
res
length(which(abs(res$par[-c(1,5,9)]) > 0.01))
t(matrix(res$par, nrow = 3))
```

n = 4

```{r}
n <- 4
Lambda <- rbind(c(runif(2,0.1,1),0,0),c(0,runif(1,0.1,1),0,runif(1,0.1,1)),c(0,0,runif(2,0.1,1)),c(0,0,0,runif(1,0.1,1)))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gamma) {
  n <- 4
  Lambda <- t(matrix(par,nrow=n))
  non_zero_par <- c(Lambda[-c(1,6,11,16)])
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2") ** 2 + (gamma * sum(abs(non_zero_par)))
  return (obj)
}

gamma_par <- 1
while(1) {
  res <- optim(par=c(runif(16,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  while (res$convergence) {
    res <- optim(par=c(runif(16,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  }
  off_diag_par <- length(which(abs(res$par[-c(1,6,11,16)]) > 0.01))
  if (off_diag_par == 3) {
    print(gamma_par)
    break
  }else if(off_diag_par < 3){
   gamma_par <<- gamma_par - 1
  }else {
    gamma_par <<- gamma_par + 1
  }
}
res
length(which(abs(res$par[-c(1,6,11,16)]) > 0.01))
t(matrix(res$par, nrow = 4))
```

```{r}
# Cholesky
n <- 4
# Lambda <- rbind(c(0.3,0,0.4,0),c(0,0.5,0.8,0),c(0,0,0.6,0),c(0,0,0.4,0.9))  # Changable coefficients
Lambda <- matrix(res$par, nrow = 4)

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_prime <- solve(chol(Sigma)) %*% chol(Sigma - omega * diag(n))

Lambda_prime
```

3.  Recover parameters with support known

```{r}
n <- 3
Lambda <- rbind(c(0.5,0.7,0),c(0,0.6,0),c(0,0,0.4))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],0),c(0,par[3],0),c(0,0,par[4]))
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2")
  return (obj)
}

optim(par=rep(0L,4),obj_fn,Sigma = Sigma,omega = omega)
```

Simulation: Recover parameters in \Lambda

Level plots

```{r}
n <- 3
Lambda <- rbind(c(0.5,0,0.9),c(0,0.6,0.7),c(0,0,0.5))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

l_1 <- seq(-1,1,0.01)
l_2 <- seq(-1,1,0.01)
obj <- c()
for (i in 1:length(l_1)) {
  l <- rbind(c(0.5,0,l_1[i]),c(0,0.6,l_2[i]),c(0,0,0.5))
  obj[i] <- norm(Sigma - t(l) %*% Sigma %*% l - omega*diag(n), type="2") ** 2
}
scatterplot3d(l_1,l_2,obj)
```

Lasso and gradient descent

n = 3

```{r}
n <- 3
# Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(0,0,runif(1,-1,1))) # G_1

Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(runif(3,-1,1))) # G_2

# Loop until the norm of A is smaller than 1
while (norm(Lambda,type="I") >= 1) {
  Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(runif(3,-1,1)))
}

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gam) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],par[3]),c(par[4],par[5],par[6]),c(par[7],par[8],par[9]))
  Lambda_ndiag <- Lambda
  diag(Lambda_ndiag) <- 0
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="F") ** 2 + gam * norm(Lambda_ndiag,type="1")
  return (obj)
}

seq_length <- 100
gam <- seq(0,100,length.out = seq_length)
res_value <- rep(0L,seq_length)
num_edge <- rep(0L,seq_length)

for (i in 1:seq_length) {
  res <- optim(par=runif(9,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  while (res$convergence) {
      res <- optim(par=runif(9,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  }
  res_value[i] <- res$value
  num_edge[i] <- length(which(abs(res$par[-c(1,5,9)]) > 1e-03))
}

df <- data.frame(gam,res_value,num_edge)

plt_value <- ggplot(df,aes(gam,res_value))
plt_num_ed <- ggplot(df,aes(gam,num_edge))

plt_value + geom_point()
plt_num_ed + geom_point()
# plt_value + geom_smooth()
```

n = 3, and treat $\omega$ as a parameter

```{r}
n <- 3
Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(0,0,runif(1,-1,1))) # G_1

# Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(runif(1,-1,3))) # G_2

# Loop until the norm of A is smaller than 1
while (norm(Lambda,type="I") >= 1) {
  Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(0,0,runif(1,-1,1)))
}

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,gam) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],par[3]),c(par[4],par[5],par[6]),c(par[7],par[8],par[9]))
  Lambda_ndiag <- Lambda
  diag(Lambda_ndiag) <- 0
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - par[10]*diag(n), type="F") ** 2 + gam * norm(Lambda_ndiag,type="1")
  return (obj)
}

gam <- seq(0,9.9,0.1)
res_value <- rep(0L,100)
num_edge <- rep(0L,100)

for (i in 1:100) {
  res <- optim(par=runif(10,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,gam=gam[i])
  while (res$convergence) {
      res <- optim(par=runif(10,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,gam=gam[i])
  }
  res_value[i] <- res$value
  num_edge[i] <- length(which(abs(res$par[-c(1,5,9,10)]) > 1e-03))
}

df <- data.frame(gam,res_value,num_edge)

plt_value <- ggplot(df,aes(gam,res_value))
plt_num_ed <- ggplot(df,aes(gam,num_edge))

plt_value + geom_point()
plt_num_ed + geom_point()
# plt_value + geom_smooth()
```

n=5

```{r}
n <- 5
Lambda <- rbind(c(runif(2,-1,1),0,0,0),c(0,runif(2,-1,1),0,0),c(0,0,runif(2,-1,1),0),c(0,0,0,runif(2,-1,1)),c(0,0,0,0,runif(1,-1,1))) # G_1

# Loop until the norm of A is smaller than 1
while (norm(Lambda,type="I") >= 1) {
  Lambda <- rbind(c(runif(2,-1,1),0,0,0),c(0,runif(2,-1,1),0,0),c(0,0,runif(2,-1,1),0),c(0,0,0,runif(2,-1,1)),c(0,0,0,0,runif(1,-1,1)))
}

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gam) {
  n <- 5
  Lambda <- matrix(par[1:(n ** 2)],nrow=n)
  Lambda_ndiag <- Lambda
  diag(Lambda_ndiag) <- 0
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="F") ** 2 + gam * norm(Lambda_ndiag,type="1")
  return (obj)
}

seq_length <- 100
gam <- seq(0,10,length.out = seq_length)
res_value <- rep(0L,seq_length)
num_edge <- rep(0L,seq_length)

for (i in 1:seq_length) {
  res <- optim(par=runif(n ** 2,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  while (res$convergence) {
      res <- optim(par=runif(n ** 2,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  }
  res_value[i] <- res$value
  num_edge[i] <- length(which(abs(res$par[-seq(1,n**2,n+1)]) > 1e-03))
}

df <- data.frame(gam,res_value,num_edge)

plt_value <- ggplot(df,aes(gam,res_value))
plt_num_ed <- ggplot(df,aes(gam,num_edge))

plt_value + geom_point()
plt_num_ed + geom_point()
# plt_value + geom_smooth()
```



