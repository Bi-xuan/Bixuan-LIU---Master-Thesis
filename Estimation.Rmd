```{r}
library('fBasics')
library('Matrix')
library("matrixcalc")

library("ggplot2")
theme_set(theme_bw())

library("scatterplot3d") # load
```



```{r}
n <- 5
# Lambda <- rbind(c(0.7,0.9,0,0,0), c(0.3,0.8,0.9,0,0),c(0,0.5,0.4,-0.6,0),c(0,0,0.76,0.9,0.65), c(0,0,0,0.8,0.5))
Lambda <- rbind(c(0.03,0,0.8,0,0),c(0,0.05,0.04,0,0),c(0.07,-0.09,0.06,0.03,0.04),c(0,0,-0.65,0.09,0), c(0,0,0.08,0,0.05)) 
omega <- 1

# Calculate Sigma
vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

f_Sigma <- c()
num_edge <- nnzero(Lambda)

for (i in 1:100) {
  Lambda_val <- runif(num_edge,-1,1)
  Lambda_t <- rbind(c(Lambda_val[1],Lambda_val[2],0,0,0), c(Lambda_val[3],Lambda_val[4],Lambda_val[5],0,0),c(0,Lambda_val[6],Lambda_val[7],-Lambda_val[8],0),c(0,0,Lambda_val[9],Lambda_val[10],Lambda_val[11]), c(0,0,0,Lambda_val[12],Lambda_val[13]))
  f_Sigma_val <- frobenius.norm(Sigma - t(Lambda_t) %*% Sigma %*% Lambda_t - diag(n))
  f_Sigma <- c(f_Sigma,f_Sigma_val)
}

plot(1:100,f_Sigma)
```

## Simulation: Recover parameters in \Lambda

Level plots
```{r}
n <- 3
Lambda <- rbind(c(0.5,0,0.9),c(0,0.6,0.7),c(0,0,0.5))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

l_1 <- seq(-1,1,0.01)
l_2 <- seq(-1,1,0.01)
obj <- c()
for (i in 1:length(l_1)) {
  l <- rbind(c(0.5,0,l_1[i]),c(0,0.6,l_2[i]),c(0,0,0.5))
  obj[i] <- norm(Sigma - t(l) %*% Sigma %*% l - omega*diag(n), type="2") ** 2
}
scatterplot3d(l_1,l_2,obj)
```

## Lasso and gradient descent

n = 3
```{r}
n <- 3
Lambda <- rbind(c(runif(1,-1,1),0,runif(1,-1,1)),c(0,runif(2,-1,1)),c(0,0,runif(1,-1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gam) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],par[3]),c(par[4],par[5],par[6]),c(par[7],par[8],par[9]))
  Lambda_ndiag <- Lambda
  diag(Lambda_ndiag) <- 0
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="F") ** 2 + gam * norm(Lambda_ndiag,type="1")
  return (obj)
}

gam <- seq(0,9.9,0.1)
res_value <- rep(0L,100)
num_edge <- rep(0L,100)

for (i in 1:100) {
  res <- optim(par=runif(9,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  while (res$convergence) {
      res <- optim(par=runif(9,-1,1), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega,gam=gam[i])
  }
  res_value[i] <- res$value
  num_edge[i] <- length(which(abs(res$par[-c(1,5,9)]) > 1e-03))
}

df <- data.frame(gam,res_value,num_edge)

plt_value <- ggplot(df,aes(gam,res_value))
plt_num_ed <- ggplot(df,aes(gam,num_edge))

plt_value + geom_point()
plt_num_ed + geom_point()
# plt_value + geom_smooth()
```


```{r}
n <- 3
# Lambda <- rbind(runif(3,0.1,1),c(0,runif(1,0.1,1),0),c(0,0,runif(1,0.1,1)))  # Changable coefficients
Lambda <- rbind(c(runif(1,0.1,1),0,runif(1,0.1,1)),c(0,runif(2,0.1,1)),c(0,0,runif(1,0.1,1)))

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gamma) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],par[3]),c(par[4],par[5],par[6]),c(par[7],par[8],par[9]))
  non_zero_par <- c(Lambda[-c(1,5,9)])
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2") ** 2 + abs(gamma * sum(abs(non_zero_par)))
  return (obj)
}

gamma_par <- 1
res <- optim(par=c(runif(9,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
while(1) {
  while (res$convergence) {
    res <- optim(par=c(runif(9,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  }
  off_diag_par <- length(which(abs(res$par[-c(1,5,9)]) > 0.01))
  if (off_diag_par == 2) {
    print(gamma_par)
    break
  }else if(off_diag_par < 2){
   gamma_par <<- gamma_par - 1
  }else {
    gamma_par <<- gamma_par + 1
  }
}
res
length(which(abs(res$par[-c(1,5,9)]) > 0.01))
t(matrix(res$par, nrow = 3))
```


n = 4
```{r}
n <- 4
Lambda <- rbind(c(runif(2,0.1,1),0,0),c(0,runif(1,0.1,1),0,runif(1,0.1,1)),c(0,0,runif(2,0.1,1)),c(0,0,0,runif(1,0.1,1)))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega,gamma) {
  n <- 4
  Lambda <- t(matrix(par,nrow=n))
  non_zero_par <- c(Lambda[-c(1,6,11,16)])
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2") ** 2 + (gamma * sum(abs(non_zero_par)))
  return (obj)
}

gamma_par <- 1
while(1) {
  res <- optim(par=c(runif(16,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  while (res$convergence) {
    res <- optim(par=c(runif(16,0,1)), method = "BFGS", obj_fn,Sigma = Sigma,omega = omega, gamma = gamma_par)
  }
  off_diag_par <- length(which(abs(res$par[-c(1,6,11,16)]) > 0.01))
  if (off_diag_par == 3) {
    print(gamma_par)
    break
  }else if(off_diag_par < 3){
   gamma_par <<- gamma_par - 1
  }else {
    gamma_par <<- gamma_par + 1
  }
}
res
length(which(abs(res$par[-c(1,6,11,16)]) > 0.01))
t(matrix(res$par, nrow = 4))
```



```{r}
# Cholesky
n <- 4
# Lambda <- rbind(c(0.3,0,0.4,0),c(0,0.5,0.8,0),c(0,0,0.6,0),c(0,0,0.4,0.9))  # Changable coefficients
Lambda <- matrix(res$par, nrow = 4)

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

Lambda_prime <- solve(chol(Sigma)) %*% chol(Sigma - omega * diag(n))

Lambda_prime
```


3. Recover parameters with support known
```{r}
n <- 3
Lambda <- rbind(c(0.5,0.7,0),c(0,0.6,0),c(0,0,0.4))  # Changable coefficients

omega <- 1

vec_Sigma <- solve(diag(n**2)-(t(Lambda) %x% t(Lambda))) %*% vec(omega * diag(n))
Sigma <- matrix(vec_Sigma, nrow = n)

# Objective function
obj_fn <- function(par,Sigma,omega) {
  n <- 3
  Lambda <- rbind(c(par[1],par[2],0),c(0,par[3],0),c(0,0,par[4]))
  obj <- norm(Sigma - t(Lambda) %*% Sigma %*% Lambda - omega*diag(n), type="2")
  return (obj)
}

optim(par=rep(0L,4),obj_fn,Sigma = Sigma,omega = omega)
```


















